题目：https://leetcode.cn/problems/longest-palindromic-substring/description/  
写得挺流畅  

# ME
我的做法(ME)使用三重循环，执行用时仅击败5.03%  

描述：第一重循环，遍历`s`字符串；第二重循环，找到后面与第一重循环相同的字符；最后一重循环用来检验是否是回文子串。

验证需要分奇偶情况，特别预想循环的最终状态：子串长度为偶数时，`left`和`right`刚好调转。

后续就需要判断是否 是更长的子串，如果是就更新ans。

# S  

更优解法是所谓的动态规划，其中`dp[i][j] = dp[i + 1][j - 1];`在`s[i] == s[j]`时直接进行判断。  
`dp[i + 1][j - 1]`在`dp[i][j]`赋值前存在，是由于第一重循环的`L`是从小到大依次判断进行的。